#pragma kernel CSMain

// Texture to write data to
RWTexture2D<float4> Result;
uint Resolution;
float Radius;

// Create a computebuffer to store the position of the spheres
struct Sphere
{
    float2 position;
    float radius;
};

struct Box
{
    float2 position;
    float2 size;
    float rotation; // in radians
};

RWStructuredBuffer<Sphere> Spheres;
RWStructuredBuffer<Box> Boxes;

float2 Rotate(float2 p, float angle)
{
    float s = sin(angle);
    float c = cos(angle);
    return float2(p.x * c - p.y * s, p.x * s + p.y * c);
}

float CircleSDF (float2 p, float2 c, float r)
{
    float2 d = p - c;
    return length(d) - r;
}

float BoxSDF (float2 p, float2 c, float2 b)
{
    float2 q = abs(p - c) - b;
    return length(max(q, 0)) + min(max(q.x, q.y), 0);
}


[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Create a circle at the middle of the texture
    float2 p = float2(Resolution / 2, Resolution / 2);
    float d = CircleSDF(id.xy, p, Resolution / 4 * Radius);
    d = clamp(d, 0, 1);
    Result[id.xy] = float4(d, d, d, 1);

/*
    float d = 1000;
    float2 p = id.xy;

    // Evaluate spheres
    for (uint i = 0; i < Spheres.Length; i++)
    {
        d = min(d, CircleSDF(p, Spheres[i].position, Spheres[i].radius));
    }

    // Evaluate boxes
    for (i = 0; i < Boxes.Length; i++)
    {
        float2 rotatedP = Rotate(p - Boxes[i].position, -Boxes[i].rotation);
        d = min(d, BoxSDF(rotatedP, float2(0, 0), Boxes[i].size));
    }
    
    d = clamp(d, 0, 1);
    Result[id.xy] = float4(d, d, d, 1);
    */
}
